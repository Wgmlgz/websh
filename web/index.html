<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css" />
    <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
    <div id="amogus-terminal"></div>

    <script>
      /* eslint-env browser */
      const term = new Terminal();
      term.open(document.getElementById('amogus-terminal'));

      //const socket = new WebSocket('ws://localhost:8761/');

      //socket.addEventListener('message', async function (event) {
      //term.write(event.data);
      //});

      //term.onData(function (data) {
      //console.log(JSON.stringify(data));
      //socket.send(data);
      //});

      let pc = new RTCPeerConnection({
        iceServers: [
          {
            urls: 'stun:stun.l.google.com:19302',
          },
        ],
      });
      let log = msg => {
        document.getElementById('logs').innerHTML += msg + '<br>';
      };

      let dataChannelOptions = {
        //ordered: false,
        //maxPacketLifeTime: 10,
      };

      let sendChannel = pc.createDataChannel('foo', dataChannelOptions);
      sendChannel.onclose = () => console.log('sendChannel has closed');
      sendChannel.onopen = () => console.log('sendChannel has opened');
      const enc = new TextDecoder('utf-8');
      sendChannel.onmessage = async e => {
        const data = e.data;
        // console.log(e);
        // const data = enc.decode(e.data);
        console.log(data);

        term.write(data);
        // log(
        //  `Message from DataChannel '${sendChannel.label}' payload '$/{e.data}'`
        //);
      };

      pc.oniceconnectionstatechange = e => log(pc.iceConnectionState);
      pc.onicecandidate = event => {
        if (event.candidate === null) {
          document.getElementById('localSessionDescription').value = btoa(
            JSON.stringify(pc.localDescription)
          );
        }
      };

      pc.onnegotiationneeded = e =>
        pc
          .createOffer()
          .then(d => pc.setLocalDescription(d))
          .catch(log);

      term.onData(function (data) {
        console.log(JSON.stringify(data));
        // socket.send(data);
        sendChannel.send(data);
      });

      window.sendMessage = () => {
        let message = document.getElementById('message').value;
        if (message === '') {
          return alert('Message must not be empty');
        }

        sendChannel.send(message);
      };

      window.startSession = () => {
        let sd = document.getElementById('remoteSessionDescription').value;
        if (sd === '') {
          return alert('Session Description must not be empty');
        }

        try {
          pc.setRemoteDescription(
            new RTCSessionDescription(JSON.parse(atob(sd)))
          );
        } catch (e) {
          alert(e);
        }
      };

      const socket = new WebSocket('ws://localhost:8000');

      socket.onopen = () => {
        // Register with unique name
        const myName = String(Math.random()); // Replace with user's unique name
        socket.send(
          JSON.stringify({
            type: 'register',
            name: myName,
            peerType: 'user',
          })
        );
      };

      socket.onmessage = async event => {
        const message = JSON.parse(event.data);
        switch (message.type) {
          case 'connection_request':
            // Users don't handle connection requests
            break;
          case 'signal':
            const data = JSON.parse(message.data);
            if (data.type === 'answer') {
              await pc.setRemoteDescription(new RTCSessionDescription(data));
            } else if (data.candidate) {
              await pc.addIceCandidate(new RTCIceCandidate(data));
            }
            break;
          case 'error':
            console.error('Error:', message.message);
            break;
          default:
            break;
        }
      };

      window.startSession = async () => {
        const targetServer = document.getElementById('targetServer').value;
        if (targetServer === '') {
          return alert('Target server name must not be empty');
        }
        const targetSession = document.getElementById('targetSession').value;
        if (targetSession === '') {
          return alert('Target session name must not be empty');
        }

        // Send connection request to signaling server
        socket.send(
          JSON.stringify({
            type: 'connect',
            target: targetServer,
          })
        );

        // Create offer and send it via the signaling server
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.send(
          JSON.stringify({
            type: 'signal',
            target: targetServer,
            session: targetSession,
            data: JSON.stringify(pc.localDescription),
          })
        );
      };

      pc.onicecandidate = event => {
        if (event.candidate) {
          socket.send(
            JSON.stringify({
              type: 'signal',
              target: document.getElementById('targetServer').value,
              data: JSON.stringify(event.candidate),
            })
          );
        }
      };
    </script>
  </head>
  <body>
    Browser base64 Session Description
    <textarea id="localSessionDescription" readonly="true"></textarea> <br />
    Golang base64 Session Description:
    <textarea id="remoteSessionDescription"></textarea> <br />
    <button onclick="window.startSession()">Start Session</button> <br />
    <br />

    Message: <textarea id="message">This is my DataChannel message!</textarea>
    <br />
    <button onclick="window.sendMessage()">Send Message</button> <br />

    
    Target Server Name:
    <input id="targetServer" type="text" /> <br />
    <input id="targetSession" type="text" /> <br />
    <button onclick="window.startSession()">Start Session</button> <br />
    <div id="logs"></div>
    <!--   <script>
      const term = new Terminal();
      term.open(document.getElementById('terminal'));

      const socket = new WebSocket('ws://localhost:8761/');

      socket.addEventListener('message', async function (event) {
        term.write(event.data);
      });

      term.onData(function (data) {
        console.log(JSON.stringify(data));
        socket.send(data);
      });
    </script> -->
  </body>
</html>
